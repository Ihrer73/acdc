// Generated by gencpp from file definitions/IkaGPS.msg
// DO NOT EDIT!


#ifndef DEFINITIONS_MESSAGE_IKAGPS_H
#define DEFINITIONS_MESSAGE_IKAGPS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace definitions
{
template <class ContainerAllocator>
struct IkaGPS_
{
  typedef IkaGPS_<ContainerAllocator> Type;

  IkaGPS_()
    : header()
    , iTimeUTC_Microseconds(0)
    , iTimeGPS_Microseconds(0)
    , iTimeHour(0)
    , iTimeMinute(0)
    , iTimeSecond(0)
    , fTimeHSecond(0.0)
    , iTimeDay(0)
    , iTimeMonth(0)
    , iTimeYear(0)
    , iSatellitesUsed(0)
    , nStatus(0)
    , nStatusExt(0)
    , fLongitude(0.0)
    , fLatitude(0.0)
    , fAltitude(0.0)
    , fPosNorthStDev(0.0)
    , fPosEastStDev(0.0)
    , fPosDownStDev(0.0)
    , fAngleHeading(0.0)
    , fAnglePitch(0.0)
    , fAngleRoll(0.0)
    , fAngleHeadingStDev(0.0)
    , fAnglePitchStDev(0.0)
    , fAngleRollStDev(0.0)
    , fUTMEast(0.0)
    , fUTMNorth(0.0)
    , fUTMHeading(0.0)
    , fSpeed2D(0.0)
    , fVelLateral(0.0)
    , fVelForward(0.0)
    , fVelNorth(0.0)
    , fVelEast(0.0)
    , fVelDown(0.0)
    , fVelNorthStDev(0.0)
    , fVelEastStDev(0.0)
    , fVelDownStDev(0.0)
    , fAccelX(0.0)
    , fAccelY(0.0)
    , fAccelZ(0.0)
    , fAngRateZ(0.0)
    , fAngRateY(0.0)
    , fAngRateX(0.0)  {
    }
  IkaGPS_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , iTimeUTC_Microseconds(0)
    , iTimeGPS_Microseconds(0)
    , iTimeHour(0)
    , iTimeMinute(0)
    , iTimeSecond(0)
    , fTimeHSecond(0.0)
    , iTimeDay(0)
    , iTimeMonth(0)
    , iTimeYear(0)
    , iSatellitesUsed(0)
    , nStatus(0)
    , nStatusExt(0)
    , fLongitude(0.0)
    , fLatitude(0.0)
    , fAltitude(0.0)
    , fPosNorthStDev(0.0)
    , fPosEastStDev(0.0)
    , fPosDownStDev(0.0)
    , fAngleHeading(0.0)
    , fAnglePitch(0.0)
    , fAngleRoll(0.0)
    , fAngleHeadingStDev(0.0)
    , fAnglePitchStDev(0.0)
    , fAngleRollStDev(0.0)
    , fUTMEast(0.0)
    , fUTMNorth(0.0)
    , fUTMHeading(0.0)
    , fSpeed2D(0.0)
    , fVelLateral(0.0)
    , fVelForward(0.0)
    , fVelNorth(0.0)
    , fVelEast(0.0)
    , fVelDown(0.0)
    , fVelNorthStDev(0.0)
    , fVelEastStDev(0.0)
    , fVelDownStDev(0.0)
    , fAccelX(0.0)
    , fAccelY(0.0)
    , fAccelZ(0.0)
    , fAngRateZ(0.0)
    , fAngRateY(0.0)
    , fAngRateX(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint64_t _iTimeUTC_Microseconds_type;
  _iTimeUTC_Microseconds_type iTimeUTC_Microseconds;

   typedef uint64_t _iTimeGPS_Microseconds_type;
  _iTimeGPS_Microseconds_type iTimeGPS_Microseconds;

   typedef uint64_t _iTimeHour_type;
  _iTimeHour_type iTimeHour;

   typedef uint64_t _iTimeMinute_type;
  _iTimeMinute_type iTimeMinute;

   typedef uint64_t _iTimeSecond_type;
  _iTimeSecond_type iTimeSecond;

   typedef double _fTimeHSecond_type;
  _fTimeHSecond_type fTimeHSecond;

   typedef uint64_t _iTimeDay_type;
  _iTimeDay_type iTimeDay;

   typedef uint64_t _iTimeMonth_type;
  _iTimeMonth_type iTimeMonth;

   typedef uint64_t _iTimeYear_type;
  _iTimeYear_type iTimeYear;

   typedef uint16_t _iSatellitesUsed_type;
  _iSatellitesUsed_type iSatellitesUsed;

   typedef int16_t _nStatus_type;
  _nStatus_type nStatus;

   typedef uint8_t _nStatusExt_type;
  _nStatusExt_type nStatusExt;

   typedef double _fLongitude_type;
  _fLongitude_type fLongitude;

   typedef double _fLatitude_type;
  _fLatitude_type fLatitude;

   typedef double _fAltitude_type;
  _fAltitude_type fAltitude;

   typedef double _fPosNorthStDev_type;
  _fPosNorthStDev_type fPosNorthStDev;

   typedef double _fPosEastStDev_type;
  _fPosEastStDev_type fPosEastStDev;

   typedef double _fPosDownStDev_type;
  _fPosDownStDev_type fPosDownStDev;

   typedef double _fAngleHeading_type;
  _fAngleHeading_type fAngleHeading;

   typedef double _fAnglePitch_type;
  _fAnglePitch_type fAnglePitch;

   typedef double _fAngleRoll_type;
  _fAngleRoll_type fAngleRoll;

   typedef double _fAngleHeadingStDev_type;
  _fAngleHeadingStDev_type fAngleHeadingStDev;

   typedef double _fAnglePitchStDev_type;
  _fAnglePitchStDev_type fAnglePitchStDev;

   typedef double _fAngleRollStDev_type;
  _fAngleRollStDev_type fAngleRollStDev;

   typedef double _fUTMEast_type;
  _fUTMEast_type fUTMEast;

   typedef double _fUTMNorth_type;
  _fUTMNorth_type fUTMNorth;

   typedef double _fUTMHeading_type;
  _fUTMHeading_type fUTMHeading;

   typedef double _fSpeed2D_type;
  _fSpeed2D_type fSpeed2D;

   typedef double _fVelLateral_type;
  _fVelLateral_type fVelLateral;

   typedef double _fVelForward_type;
  _fVelForward_type fVelForward;

   typedef double _fVelNorth_type;
  _fVelNorth_type fVelNorth;

   typedef double _fVelEast_type;
  _fVelEast_type fVelEast;

   typedef double _fVelDown_type;
  _fVelDown_type fVelDown;

   typedef double _fVelNorthStDev_type;
  _fVelNorthStDev_type fVelNorthStDev;

   typedef double _fVelEastStDev_type;
  _fVelEastStDev_type fVelEastStDev;

   typedef double _fVelDownStDev_type;
  _fVelDownStDev_type fVelDownStDev;

   typedef double _fAccelX_type;
  _fAccelX_type fAccelX;

   typedef double _fAccelY_type;
  _fAccelY_type fAccelY;

   typedef double _fAccelZ_type;
  _fAccelZ_type fAccelZ;

   typedef double _fAngRateZ_type;
  _fAngRateZ_type fAngRateZ;

   typedef double _fAngRateY_type;
  _fAngRateY_type fAngRateY;

   typedef double _fAngRateX_type;
  _fAngRateX_type fAngRateX;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(STATUS_NO_FIX)
  #undef STATUS_NO_FIX
#endif
#if defined(_WIN32) && defined(STATUS_FIX)
  #undef STATUS_FIX
#endif
#if defined(_WIN32) && defined(STATUS_SBAS_FIX)
  #undef STATUS_SBAS_FIX
#endif
#if defined(_WIN32) && defined(STATUS_GBAS_FIX)
  #undef STATUS_GBAS_FIX
#endif
#if defined(_WIN32) && defined(STATUS_DGPS_FIX)
  #undef STATUS_DGPS_FIX
#endif
#if defined(_WIN32) && defined(STATUS_WAAS_FIX)
  #undef STATUS_WAAS_FIX
#endif
#if defined(_WIN32) && defined(STATUS_EXT_NONE)
  #undef STATUS_EXT_NONE
#endif
#if defined(_WIN32) && defined(STATUS_EXT_SEARCH)
  #undef STATUS_EXT_SEARCH
#endif
#if defined(_WIN32) && defined(STATUS_EXT_DOPPLER)
  #undef STATUS_EXT_DOPPLER
#endif
#if defined(_WIN32) && defined(STATUS_EXT_SPS)
  #undef STATUS_EXT_SPS
#endif
#if defined(_WIN32) && defined(STATUS_EXT_DIFERENTIAL)
  #undef STATUS_EXT_DIFERENTIAL
#endif
#if defined(_WIN32) && defined(STATUS_EXT_RTK_FLOAT)
  #undef STATUS_EXT_RTK_FLOAT
#endif
#if defined(_WIN32) && defined(STATUS_EXT_RTK_INTEGER)
  #undef STATUS_EXT_RTK_INTEGER
#endif
#if defined(_WIN32) && defined(STATUS_EXT_WAAS)
  #undef STATUS_EXT_WAAS
#endif
#if defined(_WIN32) && defined(STATUS_EXT_OMNISTAR)
  #undef STATUS_EXT_OMNISTAR
#endif
#if defined(_WIN32) && defined(STATUS_EXT_OMNISTAR_HP)
  #undef STATUS_EXT_OMNISTAR_HP
#endif
#if defined(_WIN32) && defined(STATUS_EXT_NO_DATA)
  #undef STATUS_EXT_NO_DATA
#endif
#if defined(_WIN32) && defined(STATUS_EXT_BLANKED)
  #undef STATUS_EXT_BLANKED
#endif
#if defined(_WIN32) && defined(STATUS_EXT_DOPPLER_PP)
  #undef STATUS_EXT_DOPPLER_PP
#endif
#if defined(_WIN32) && defined(STATUS_EXT_SPS_PP)
  #undef STATUS_EXT_SPS_PP
#endif
#if defined(_WIN32) && defined(STATUS_EXT_DIFERENTIAL_PP)
  #undef STATUS_EXT_DIFERENTIAL_PP
#endif
#if defined(_WIN32) && defined(STATUS_EXT_RTK_FLOAT_PP)
  #undef STATUS_EXT_RTK_FLOAT_PP
#endif
#if defined(_WIN32) && defined(STATUS_EXT_RTK_INTEGER_PP)
  #undef STATUS_EXT_RTK_INTEGER_PP
#endif
#if defined(_WIN32) && defined(STATUS_EXT_OMNISTAR_XP)
  #undef STATUS_EXT_OMNISTAR_XP
#endif
#if defined(_WIN32) && defined(STATUS_EXT_CDGPS)
  #undef STATUS_EXT_CDGPS
#endif
#if defined(_WIN32) && defined(STATUS_EXT_NOT_RECOGNIZED)
  #undef STATUS_EXT_NOT_RECOGNIZED
#endif
#if defined(_WIN32) && defined(STATUS_EXT_GXDOPPLER)
  #undef STATUS_EXT_GXDOPPLER
#endif
#if defined(_WIN32) && defined(STATUS_EXT_GXSPS)
  #undef STATUS_EXT_GXSPS
#endif
#if defined(_WIN32) && defined(STATUS_EXT_GSDIFFERENTIAL)
  #undef STATUS_EXT_GSDIFFERENTIAL
#endif
#if defined(_WIN32) && defined(STATUS_EXT_GXFLOAT)
  #undef STATUS_EXT_GXFLOAT
#endif
#if defined(_WIN32) && defined(STATUS_EXT_GXINTEGER)
  #undef STATUS_EXT_GXINTEGER
#endif
#if defined(_WIN32) && defined(STATUS_EXT_IXDOPPLER)
  #undef STATUS_EXT_IXDOPPLER
#endif
#if defined(_WIN32) && defined(STATUS_EXT_IXSPS)
  #undef STATUS_EXT_IXSPS
#endif
#if defined(_WIN32) && defined(STATUS_EXT_IXDIFERENTIAL)
  #undef STATUS_EXT_IXDIFERENTIAL
#endif
#if defined(_WIN32) && defined(STATUS_EXT_IXFLOAT)
  #undef STATUS_EXT_IXFLOAT
#endif
#if defined(_WIN32) && defined(STATUS_EXT_IXINTEGER)
  #undef STATUS_EXT_IXINTEGER
#endif
#if defined(_WIN32) && defined(STATUS_EXT_PPP_CONVERGING)
  #undef STATUS_EXT_PPP_CONVERGING
#endif
#if defined(_WIN32) && defined(STATUS_EXT_PPP)
  #undef STATUS_EXT_PPP
#endif
#if defined(_WIN32) && defined(STATUS_EXT_UNKNOWN)
  #undef STATUS_EXT_UNKNOWN
#endif

  enum {
    STATUS_NO_FIX = -1,
    STATUS_FIX = 0,
    STATUS_SBAS_FIX = 1,
    STATUS_GBAS_FIX = 2,
    STATUS_DGPS_FIX = 18,
    STATUS_WAAS_FIX = 33,
    STATUS_EXT_NONE = 0u,
    STATUS_EXT_SEARCH = 1u,
    STATUS_EXT_DOPPLER = 2u,
    STATUS_EXT_SPS = 3u,
    STATUS_EXT_DIFERENTIAL = 4u,
    STATUS_EXT_RTK_FLOAT = 5u,
    STATUS_EXT_RTK_INTEGER = 6u,
    STATUS_EXT_WAAS = 7u,
    STATUS_EXT_OMNISTAR = 8u,
    STATUS_EXT_OMNISTAR_HP = 9u,
    STATUS_EXT_NO_DATA = 10u,
    STATUS_EXT_BLANKED = 11u,
    STATUS_EXT_DOPPLER_PP = 12u,
    STATUS_EXT_SPS_PP = 13u,
    STATUS_EXT_DIFERENTIAL_PP = 14u,
    STATUS_EXT_RTK_FLOAT_PP = 15u,
    STATUS_EXT_RTK_INTEGER_PP = 16u,
    STATUS_EXT_OMNISTAR_XP = 17u,
    STATUS_EXT_CDGPS = 18u,
    STATUS_EXT_NOT_RECOGNIZED = 19u,
    STATUS_EXT_GXDOPPLER = 20u,
    STATUS_EXT_GXSPS = 21u,
    STATUS_EXT_GSDIFFERENTIAL = 22u,
    STATUS_EXT_GXFLOAT = 23u,
    STATUS_EXT_GXINTEGER = 24u,
    STATUS_EXT_IXDOPPLER = 25u,
    STATUS_EXT_IXSPS = 26u,
    STATUS_EXT_IXDIFERENTIAL = 27u,
    STATUS_EXT_IXFLOAT = 28u,
    STATUS_EXT_IXINTEGER = 29u,
    STATUS_EXT_PPP_CONVERGING = 30u,
    STATUS_EXT_PPP = 31u,
    STATUS_EXT_UNKNOWN = 32u,
  };


  typedef boost::shared_ptr< ::definitions::IkaGPS_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::definitions::IkaGPS_<ContainerAllocator> const> ConstPtr;

}; // struct IkaGPS_

typedef ::definitions::IkaGPS_<std::allocator<void> > IkaGPS;

typedef boost::shared_ptr< ::definitions::IkaGPS > IkaGPSPtr;
typedef boost::shared_ptr< ::definitions::IkaGPS const> IkaGPSConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::definitions::IkaGPS_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::definitions::IkaGPS_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::definitions::IkaGPS_<ContainerAllocator1> & lhs, const ::definitions::IkaGPS_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.iTimeUTC_Microseconds == rhs.iTimeUTC_Microseconds &&
    lhs.iTimeGPS_Microseconds == rhs.iTimeGPS_Microseconds &&
    lhs.iTimeHour == rhs.iTimeHour &&
    lhs.iTimeMinute == rhs.iTimeMinute &&
    lhs.iTimeSecond == rhs.iTimeSecond &&
    lhs.fTimeHSecond == rhs.fTimeHSecond &&
    lhs.iTimeDay == rhs.iTimeDay &&
    lhs.iTimeMonth == rhs.iTimeMonth &&
    lhs.iTimeYear == rhs.iTimeYear &&
    lhs.iSatellitesUsed == rhs.iSatellitesUsed &&
    lhs.nStatus == rhs.nStatus &&
    lhs.nStatusExt == rhs.nStatusExt &&
    lhs.fLongitude == rhs.fLongitude &&
    lhs.fLatitude == rhs.fLatitude &&
    lhs.fAltitude == rhs.fAltitude &&
    lhs.fPosNorthStDev == rhs.fPosNorthStDev &&
    lhs.fPosEastStDev == rhs.fPosEastStDev &&
    lhs.fPosDownStDev == rhs.fPosDownStDev &&
    lhs.fAngleHeading == rhs.fAngleHeading &&
    lhs.fAnglePitch == rhs.fAnglePitch &&
    lhs.fAngleRoll == rhs.fAngleRoll &&
    lhs.fAngleHeadingStDev == rhs.fAngleHeadingStDev &&
    lhs.fAnglePitchStDev == rhs.fAnglePitchStDev &&
    lhs.fAngleRollStDev == rhs.fAngleRollStDev &&
    lhs.fUTMEast == rhs.fUTMEast &&
    lhs.fUTMNorth == rhs.fUTMNorth &&
    lhs.fUTMHeading == rhs.fUTMHeading &&
    lhs.fSpeed2D == rhs.fSpeed2D &&
    lhs.fVelLateral == rhs.fVelLateral &&
    lhs.fVelForward == rhs.fVelForward &&
    lhs.fVelNorth == rhs.fVelNorth &&
    lhs.fVelEast == rhs.fVelEast &&
    lhs.fVelDown == rhs.fVelDown &&
    lhs.fVelNorthStDev == rhs.fVelNorthStDev &&
    lhs.fVelEastStDev == rhs.fVelEastStDev &&
    lhs.fVelDownStDev == rhs.fVelDownStDev &&
    lhs.fAccelX == rhs.fAccelX &&
    lhs.fAccelY == rhs.fAccelY &&
    lhs.fAccelZ == rhs.fAccelZ &&
    lhs.fAngRateZ == rhs.fAngRateZ &&
    lhs.fAngRateY == rhs.fAngRateY &&
    lhs.fAngRateX == rhs.fAngRateX;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::definitions::IkaGPS_<ContainerAllocator1> & lhs, const ::definitions::IkaGPS_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace definitions

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::definitions::IkaGPS_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::definitions::IkaGPS_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::definitions::IkaGPS_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::definitions::IkaGPS_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::definitions::IkaGPS_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::definitions::IkaGPS_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::definitions::IkaGPS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "be18f6276d518be76f37af636e04fd9f";
  }

  static const char* value(const ::definitions::IkaGPS_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xbe18f6276d518be7ULL;
  static const uint64_t static_value2 = 0x6f37af636e04fd9fULL;
};

template<class ContainerAllocator>
struct DataType< ::definitions::IkaGPS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "definitions/IkaGPS";
  }

  static const char* value(const ::definitions::IkaGPS_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::definitions::IkaGPS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Header header\n"
"\n"
"# GPS time variables\n"
"uint64 iTimeUTC_Microseconds\n"
"uint64 iTimeGPS_Microseconds\n"
"uint64 iTimeHour\n"
"uint64 iTimeMinute\n"
"uint64 iTimeSecond\n"
"float64 fTimeHSecond\n"
"uint64 iTimeDay\n"
"uint64 iTimeMonth\n"
"uint64 iTimeYear\n"
"\n"
"# GPS quality variables\n"
"uint16 iSatellitesUsed # Number of satellites\n"
"\n"
"# Measurement status\n"
"int16 STATUS_NO_FIX=-1   # Unable to fix position\n"
"int16 STATUS_FIX=0       # Normal fix\n"
"int16 STATUS_SBAS_FIX=1  # Fixed using a satellite-based augmentation system\n"
"int16 STATUS_GBAS_FIX=2  #          or a ground-based augmentation system\n"
"int16 STATUS_DGPS_FIX=18 # Fixed with DGPS\n"
"int16 STATUS_WAAS_FIX=33 # Fixed with WAAS\n"
"int16 nStatus\n"
"\n"
"# Extended Measurement status\n"
"uint8 STATUS_EXT_NONE=0 #The GPS is not able to make this measurement.\n"
"uint8 STATUS_EXT_SEARCH=1 #The GPS system is solving ambiguities and searching for a valid solution. \n"
"uint8 STATUS_EXT_DOPPLER=2 #GPS measurement is based on a Doppler measurement. \n"
"uint8 STATUS_EXT_SPS=3 #Standard Positioning Service, the GPS measurement has no additional external corrections.\n"
"uint8 STATUS_EXT_DIFERENTIAL=4 #The GPS measurement used pseudo-range differential corrections. \n"
"uint8 STATUS_EXT_RTK_FLOAT=5 #The GPS measurement used L1 carrier-phase differential corrections to give a floating ambiguity solution.\n"
"uint8 STATUS_EXT_RTK_INTEGER=6 #The GPS measurement used L1/L2 carrier-phase differential corrections to give an integer ambiguity solution. \n"
"uint8 STATUS_EXT_WAAS=7 #The GPS measurement used SBAS corrections.\n"
"uint8 STATUS_EXT_OMNISTAR=8 #The GPS measurement used OmniSTAR VBS corrections.\n"
"uint8 STATUS_EXT_OMNISTAR_HP=9 #The GPS measurement used OmniSTAR HP corrections. \n"
"uint8 STATUS_EXT_NO_DATA=10 #No Data.\n"
"uint8 STATUS_EXT_BLANKED=11 #Blanked. \n"
"uint8 STATUS_EXT_DOPPLER_PP=12 #Doppler GPS measurement post-processed. \n"
"uint8 STATUS_EXT_SPS_PP=13 #SPS GPS measurement post-processed. \n"
"uint8 STATUS_EXT_DIFERENTIAL_PP=14 #Differential GPS measurement post-processed. \n"
"uint8 STATUS_EXT_RTK_FLOAT_PP=15 #RTK Float GPS measurement post-processed.\n"
"uint8 STATUS_EXT_RTK_INTEGER_PP=16 #RTK Integer GPS measurement post-processed.\n"
"uint8 STATUS_EXT_OMNISTAR_XP=17 #The GPS measurement used OmniSTAR XP corrections.\n"
"uint8 STATUS_EXT_CDGPS=18 #The GPS measurement used real time Canada wide DGPS service.\n"
"uint8 STATUS_EXT_NOT_RECOGNIZED=19 #Not recognised.\n"
"uint8 STATUS_EXT_GXDOPPLER=20 #Computed by combining raw Doppler measurements. \n"
"uint8 STATUS_EXT_GXSPS=21 #Computed by combining raw pseudo-range measurements. \n"
"uint8 STATUS_EXT_GSDIFFERENTIAL=22 #Computed by combining raw pseudo-range measurements and differential corrections. \n"
"uint8 STATUS_EXT_GXFLOAT=23 #Computed by combining raw pseudo-range and L1 carrier-phase measurements and differential corrections. \n"
"uint8 STATUS_EXT_GXINTEGER=24 #Computed by combining raw pseudo-range and L1/L2 carrier-phase measurements and differential corrections. \n"
"uint8 STATUS_EXT_IXDOPPLER=25 #Single-satellite updates from raw Doppler measurements.\n"
"uint8 STATUS_EXT_IXSPS=26 #Single-satellite updates from raw pseudo-range measurements. \n"
"uint8 STATUS_EXT_IXDIFERENTIAL=27 #Single-satellite updates from raw pseudo-range measurements and differential corrections. \n"
"uint8 STATUS_EXT_IXFLOAT=28 #Single-satellite updates from raw pseudo-range and L1 carrier-phase measurements and differential corrections.\n"
"uint8 STATUS_EXT_IXINTEGER=29 #Single-satellite updates from raw pseudo-range and L1/L2 carrier-phase measurements and differential corrections. \n"
"uint8 STATUS_EXT_PPP_CONVERGING=30 #Converging PPP (Precise Point Positioning) from global PPP corrections.\n"
"uint8 STATUS_EXT_PPP=31 #Converged PPP (Precise Point Positioning) from global PPP corrections. \n"
"uint8 STATUS_EXT_UNKNOWN=32 #Unknown.\n"
"uint8 nStatusExt\n"
"\n"
"# GPS location variables\n"
"float64 fLongitude\n"
"float64 fLatitude\n"
"float64 fAltitude\n"
"float64 fPosNorthStDev\n"
"float64 fPosEastStDev\n"
"float64 fPosDownStDev\n"
"\n"
"# GPS position variables\n"
"float64 fAngleHeading\n"
"float64 fAnglePitch\n"
"float64 fAngleRoll\n"
"float64 fAngleHeadingStDev\n"
"float64 fAnglePitchStDev\n"
"float64 fAngleRollStDev\n"
"\n"
"# UTM Postition\n"
"float64 fUTMEast\n"
"float64 fUTMNorth\n"
"float64 fUTMHeading\n"
"\n"
"# GPS velocity variables\n"
"float64 fSpeed2D\n"
"float64 fVelLateral\n"
"float64 fVelForward\n"
"float64 fVelNorth\n"
"float64 fVelEast\n"
"float64 fVelDown\n"
"float64 fVelNorthStDev\n"
"float64 fVelEastStDev\n"
"float64 fVelDownStDev\n"
"\n"
"# GPS acceleration variables\n"
"float64 fAccelX\n"
"float64 fAccelY\n"
"float64 fAccelZ\n"
"float64 fAngRateZ\n"
"float64 fAngRateY\n"
"float64 fAngRateX\n"
"\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::definitions::IkaGPS_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::definitions::IkaGPS_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.iTimeUTC_Microseconds);
      stream.next(m.iTimeGPS_Microseconds);
      stream.next(m.iTimeHour);
      stream.next(m.iTimeMinute);
      stream.next(m.iTimeSecond);
      stream.next(m.fTimeHSecond);
      stream.next(m.iTimeDay);
      stream.next(m.iTimeMonth);
      stream.next(m.iTimeYear);
      stream.next(m.iSatellitesUsed);
      stream.next(m.nStatus);
      stream.next(m.nStatusExt);
      stream.next(m.fLongitude);
      stream.next(m.fLatitude);
      stream.next(m.fAltitude);
      stream.next(m.fPosNorthStDev);
      stream.next(m.fPosEastStDev);
      stream.next(m.fPosDownStDev);
      stream.next(m.fAngleHeading);
      stream.next(m.fAnglePitch);
      stream.next(m.fAngleRoll);
      stream.next(m.fAngleHeadingStDev);
      stream.next(m.fAnglePitchStDev);
      stream.next(m.fAngleRollStDev);
      stream.next(m.fUTMEast);
      stream.next(m.fUTMNorth);
      stream.next(m.fUTMHeading);
      stream.next(m.fSpeed2D);
      stream.next(m.fVelLateral);
      stream.next(m.fVelForward);
      stream.next(m.fVelNorth);
      stream.next(m.fVelEast);
      stream.next(m.fVelDown);
      stream.next(m.fVelNorthStDev);
      stream.next(m.fVelEastStDev);
      stream.next(m.fVelDownStDev);
      stream.next(m.fAccelX);
      stream.next(m.fAccelY);
      stream.next(m.fAccelZ);
      stream.next(m.fAngRateZ);
      stream.next(m.fAngRateY);
      stream.next(m.fAngRateX);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct IkaGPS_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::definitions::IkaGPS_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::definitions::IkaGPS_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "iTimeUTC_Microseconds: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.iTimeUTC_Microseconds);
    s << indent << "iTimeGPS_Microseconds: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.iTimeGPS_Microseconds);
    s << indent << "iTimeHour: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.iTimeHour);
    s << indent << "iTimeMinute: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.iTimeMinute);
    s << indent << "iTimeSecond: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.iTimeSecond);
    s << indent << "fTimeHSecond: ";
    Printer<double>::stream(s, indent + "  ", v.fTimeHSecond);
    s << indent << "iTimeDay: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.iTimeDay);
    s << indent << "iTimeMonth: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.iTimeMonth);
    s << indent << "iTimeYear: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.iTimeYear);
    s << indent << "iSatellitesUsed: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.iSatellitesUsed);
    s << indent << "nStatus: ";
    Printer<int16_t>::stream(s, indent + "  ", v.nStatus);
    s << indent << "nStatusExt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.nStatusExt);
    s << indent << "fLongitude: ";
    Printer<double>::stream(s, indent + "  ", v.fLongitude);
    s << indent << "fLatitude: ";
    Printer<double>::stream(s, indent + "  ", v.fLatitude);
    s << indent << "fAltitude: ";
    Printer<double>::stream(s, indent + "  ", v.fAltitude);
    s << indent << "fPosNorthStDev: ";
    Printer<double>::stream(s, indent + "  ", v.fPosNorthStDev);
    s << indent << "fPosEastStDev: ";
    Printer<double>::stream(s, indent + "  ", v.fPosEastStDev);
    s << indent << "fPosDownStDev: ";
    Printer<double>::stream(s, indent + "  ", v.fPosDownStDev);
    s << indent << "fAngleHeading: ";
    Printer<double>::stream(s, indent + "  ", v.fAngleHeading);
    s << indent << "fAnglePitch: ";
    Printer<double>::stream(s, indent + "  ", v.fAnglePitch);
    s << indent << "fAngleRoll: ";
    Printer<double>::stream(s, indent + "  ", v.fAngleRoll);
    s << indent << "fAngleHeadingStDev: ";
    Printer<double>::stream(s, indent + "  ", v.fAngleHeadingStDev);
    s << indent << "fAnglePitchStDev: ";
    Printer<double>::stream(s, indent + "  ", v.fAnglePitchStDev);
    s << indent << "fAngleRollStDev: ";
    Printer<double>::stream(s, indent + "  ", v.fAngleRollStDev);
    s << indent << "fUTMEast: ";
    Printer<double>::stream(s, indent + "  ", v.fUTMEast);
    s << indent << "fUTMNorth: ";
    Printer<double>::stream(s, indent + "  ", v.fUTMNorth);
    s << indent << "fUTMHeading: ";
    Printer<double>::stream(s, indent + "  ", v.fUTMHeading);
    s << indent << "fSpeed2D: ";
    Printer<double>::stream(s, indent + "  ", v.fSpeed2D);
    s << indent << "fVelLateral: ";
    Printer<double>::stream(s, indent + "  ", v.fVelLateral);
    s << indent << "fVelForward: ";
    Printer<double>::stream(s, indent + "  ", v.fVelForward);
    s << indent << "fVelNorth: ";
    Printer<double>::stream(s, indent + "  ", v.fVelNorth);
    s << indent << "fVelEast: ";
    Printer<double>::stream(s, indent + "  ", v.fVelEast);
    s << indent << "fVelDown: ";
    Printer<double>::stream(s, indent + "  ", v.fVelDown);
    s << indent << "fVelNorthStDev: ";
    Printer<double>::stream(s, indent + "  ", v.fVelNorthStDev);
    s << indent << "fVelEastStDev: ";
    Printer<double>::stream(s, indent + "  ", v.fVelEastStDev);
    s << indent << "fVelDownStDev: ";
    Printer<double>::stream(s, indent + "  ", v.fVelDownStDev);
    s << indent << "fAccelX: ";
    Printer<double>::stream(s, indent + "  ", v.fAccelX);
    s << indent << "fAccelY: ";
    Printer<double>::stream(s, indent + "  ", v.fAccelY);
    s << indent << "fAccelZ: ";
    Printer<double>::stream(s, indent + "  ", v.fAccelZ);
    s << indent << "fAngRateZ: ";
    Printer<double>::stream(s, indent + "  ", v.fAngRateZ);
    s << indent << "fAngRateY: ";
    Printer<double>::stream(s, indent + "  ", v.fAngRateY);
    s << indent << "fAngRateX: ";
    Printer<double>::stream(s, indent + "  ", v.fAngRateX);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DEFINITIONS_MESSAGE_IKAGPS_H
