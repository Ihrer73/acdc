# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from definitions/IkaGPS.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg

class IkaGPS(genpy.Message):
  _md5sum = "be18f6276d518be76f37af636e04fd9f"
  _type = "definitions/IkaGPS"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """std_msgs/Header header

# GPS time variables
uint64 iTimeUTC_Microseconds
uint64 iTimeGPS_Microseconds
uint64 iTimeHour
uint64 iTimeMinute
uint64 iTimeSecond
float64 fTimeHSecond
uint64 iTimeDay
uint64 iTimeMonth
uint64 iTimeYear

# GPS quality variables
uint16 iSatellitesUsed # Number of satellites

# Measurement status
int16 STATUS_NO_FIX=-1   # Unable to fix position
int16 STATUS_FIX=0       # Normal fix
int16 STATUS_SBAS_FIX=1  # Fixed using a satellite-based augmentation system
int16 STATUS_GBAS_FIX=2  #          or a ground-based augmentation system
int16 STATUS_DGPS_FIX=18 # Fixed with DGPS
int16 STATUS_WAAS_FIX=33 # Fixed with WAAS
int16 nStatus

# Extended Measurement status
uint8 STATUS_EXT_NONE=0 #The GPS is not able to make this measurement.
uint8 STATUS_EXT_SEARCH=1 #The GPS system is solving ambiguities and searching for a valid solution. 
uint8 STATUS_EXT_DOPPLER=2 #GPS measurement is based on a Doppler measurement. 
uint8 STATUS_EXT_SPS=3 #Standard Positioning Service, the GPS measurement has no additional external corrections.
uint8 STATUS_EXT_DIFERENTIAL=4 #The GPS measurement used pseudo-range differential corrections. 
uint8 STATUS_EXT_RTK_FLOAT=5 #The GPS measurement used L1 carrier-phase differential corrections to give a floating ambiguity solution.
uint8 STATUS_EXT_RTK_INTEGER=6 #The GPS measurement used L1/L2 carrier-phase differential corrections to give an integer ambiguity solution. 
uint8 STATUS_EXT_WAAS=7 #The GPS measurement used SBAS corrections.
uint8 STATUS_EXT_OMNISTAR=8 #The GPS measurement used OmniSTAR VBS corrections.
uint8 STATUS_EXT_OMNISTAR_HP=9 #The GPS measurement used OmniSTAR HP corrections. 
uint8 STATUS_EXT_NO_DATA=10 #No Data.
uint8 STATUS_EXT_BLANKED=11 #Blanked. 
uint8 STATUS_EXT_DOPPLER_PP=12 #Doppler GPS measurement post-processed. 
uint8 STATUS_EXT_SPS_PP=13 #SPS GPS measurement post-processed. 
uint8 STATUS_EXT_DIFERENTIAL_PP=14 #Differential GPS measurement post-processed. 
uint8 STATUS_EXT_RTK_FLOAT_PP=15 #RTK Float GPS measurement post-processed.
uint8 STATUS_EXT_RTK_INTEGER_PP=16 #RTK Integer GPS measurement post-processed.
uint8 STATUS_EXT_OMNISTAR_XP=17 #The GPS measurement used OmniSTAR XP corrections.
uint8 STATUS_EXT_CDGPS=18 #The GPS measurement used real time Canada wide DGPS service.
uint8 STATUS_EXT_NOT_RECOGNIZED=19 #Not recognised.
uint8 STATUS_EXT_GXDOPPLER=20 #Computed by combining raw Doppler measurements. 
uint8 STATUS_EXT_GXSPS=21 #Computed by combining raw pseudo-range measurements. 
uint8 STATUS_EXT_GSDIFFERENTIAL=22 #Computed by combining raw pseudo-range measurements and differential corrections. 
uint8 STATUS_EXT_GXFLOAT=23 #Computed by combining raw pseudo-range and L1 carrier-phase measurements and differential corrections. 
uint8 STATUS_EXT_GXINTEGER=24 #Computed by combining raw pseudo-range and L1/L2 carrier-phase measurements and differential corrections. 
uint8 STATUS_EXT_IXDOPPLER=25 #Single-satellite updates from raw Doppler measurements.
uint8 STATUS_EXT_IXSPS=26 #Single-satellite updates from raw pseudo-range measurements. 
uint8 STATUS_EXT_IXDIFERENTIAL=27 #Single-satellite updates from raw pseudo-range measurements and differential corrections. 
uint8 STATUS_EXT_IXFLOAT=28 #Single-satellite updates from raw pseudo-range and L1 carrier-phase measurements and differential corrections.
uint8 STATUS_EXT_IXINTEGER=29 #Single-satellite updates from raw pseudo-range and L1/L2 carrier-phase measurements and differential corrections. 
uint8 STATUS_EXT_PPP_CONVERGING=30 #Converging PPP (Precise Point Positioning) from global PPP corrections.
uint8 STATUS_EXT_PPP=31 #Converged PPP (Precise Point Positioning) from global PPP corrections. 
uint8 STATUS_EXT_UNKNOWN=32 #Unknown.
uint8 nStatusExt

# GPS location variables
float64 fLongitude
float64 fLatitude
float64 fAltitude
float64 fPosNorthStDev
float64 fPosEastStDev
float64 fPosDownStDev

# GPS position variables
float64 fAngleHeading
float64 fAnglePitch
float64 fAngleRoll
float64 fAngleHeadingStDev
float64 fAnglePitchStDev
float64 fAngleRollStDev

# UTM Postition
float64 fUTMEast
float64 fUTMNorth
float64 fUTMHeading

# GPS velocity variables
float64 fSpeed2D
float64 fVelLateral
float64 fVelForward
float64 fVelNorth
float64 fVelEast
float64 fVelDown
float64 fVelNorthStDev
float64 fVelEastStDev
float64 fVelDownStDev

# GPS acceleration variables
float64 fAccelX
float64 fAccelY
float64 fAccelZ
float64 fAngRateZ
float64 fAngRateY
float64 fAngRateX


================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id
"""
  # Pseudo-constants
  STATUS_NO_FIX = -1
  STATUS_FIX = 0
  STATUS_SBAS_FIX = 1
  STATUS_GBAS_FIX = 2
  STATUS_DGPS_FIX = 18
  STATUS_WAAS_FIX = 33
  STATUS_EXT_NONE = 0
  STATUS_EXT_SEARCH = 1
  STATUS_EXT_DOPPLER = 2
  STATUS_EXT_SPS = 3
  STATUS_EXT_DIFERENTIAL = 4
  STATUS_EXT_RTK_FLOAT = 5
  STATUS_EXT_RTK_INTEGER = 6
  STATUS_EXT_WAAS = 7
  STATUS_EXT_OMNISTAR = 8
  STATUS_EXT_OMNISTAR_HP = 9
  STATUS_EXT_NO_DATA = 10
  STATUS_EXT_BLANKED = 11
  STATUS_EXT_DOPPLER_PP = 12
  STATUS_EXT_SPS_PP = 13
  STATUS_EXT_DIFERENTIAL_PP = 14
  STATUS_EXT_RTK_FLOAT_PP = 15
  STATUS_EXT_RTK_INTEGER_PP = 16
  STATUS_EXT_OMNISTAR_XP = 17
  STATUS_EXT_CDGPS = 18
  STATUS_EXT_NOT_RECOGNIZED = 19
  STATUS_EXT_GXDOPPLER = 20
  STATUS_EXT_GXSPS = 21
  STATUS_EXT_GSDIFFERENTIAL = 22
  STATUS_EXT_GXFLOAT = 23
  STATUS_EXT_GXINTEGER = 24
  STATUS_EXT_IXDOPPLER = 25
  STATUS_EXT_IXSPS = 26
  STATUS_EXT_IXDIFERENTIAL = 27
  STATUS_EXT_IXFLOAT = 28
  STATUS_EXT_IXINTEGER = 29
  STATUS_EXT_PPP_CONVERGING = 30
  STATUS_EXT_PPP = 31
  STATUS_EXT_UNKNOWN = 32

  __slots__ = ['header','iTimeUTC_Microseconds','iTimeGPS_Microseconds','iTimeHour','iTimeMinute','iTimeSecond','fTimeHSecond','iTimeDay','iTimeMonth','iTimeYear','iSatellitesUsed','nStatus','nStatusExt','fLongitude','fLatitude','fAltitude','fPosNorthStDev','fPosEastStDev','fPosDownStDev','fAngleHeading','fAnglePitch','fAngleRoll','fAngleHeadingStDev','fAnglePitchStDev','fAngleRollStDev','fUTMEast','fUTMNorth','fUTMHeading','fSpeed2D','fVelLateral','fVelForward','fVelNorth','fVelEast','fVelDown','fVelNorthStDev','fVelEastStDev','fVelDownStDev','fAccelX','fAccelY','fAccelZ','fAngRateZ','fAngRateY','fAngRateX']
  _slot_types = ['std_msgs/Header','uint64','uint64','uint64','uint64','uint64','float64','uint64','uint64','uint64','uint16','int16','uint8','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,iTimeUTC_Microseconds,iTimeGPS_Microseconds,iTimeHour,iTimeMinute,iTimeSecond,fTimeHSecond,iTimeDay,iTimeMonth,iTimeYear,iSatellitesUsed,nStatus,nStatusExt,fLongitude,fLatitude,fAltitude,fPosNorthStDev,fPosEastStDev,fPosDownStDev,fAngleHeading,fAnglePitch,fAngleRoll,fAngleHeadingStDev,fAnglePitchStDev,fAngleRollStDev,fUTMEast,fUTMNorth,fUTMHeading,fSpeed2D,fVelLateral,fVelForward,fVelNorth,fVelEast,fVelDown,fVelNorthStDev,fVelEastStDev,fVelDownStDev,fAccelX,fAccelY,fAccelZ,fAngRateZ,fAngRateY,fAngRateX

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(IkaGPS, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.iTimeUTC_Microseconds is None:
        self.iTimeUTC_Microseconds = 0
      if self.iTimeGPS_Microseconds is None:
        self.iTimeGPS_Microseconds = 0
      if self.iTimeHour is None:
        self.iTimeHour = 0
      if self.iTimeMinute is None:
        self.iTimeMinute = 0
      if self.iTimeSecond is None:
        self.iTimeSecond = 0
      if self.fTimeHSecond is None:
        self.fTimeHSecond = 0.
      if self.iTimeDay is None:
        self.iTimeDay = 0
      if self.iTimeMonth is None:
        self.iTimeMonth = 0
      if self.iTimeYear is None:
        self.iTimeYear = 0
      if self.iSatellitesUsed is None:
        self.iSatellitesUsed = 0
      if self.nStatus is None:
        self.nStatus = 0
      if self.nStatusExt is None:
        self.nStatusExt = 0
      if self.fLongitude is None:
        self.fLongitude = 0.
      if self.fLatitude is None:
        self.fLatitude = 0.
      if self.fAltitude is None:
        self.fAltitude = 0.
      if self.fPosNorthStDev is None:
        self.fPosNorthStDev = 0.
      if self.fPosEastStDev is None:
        self.fPosEastStDev = 0.
      if self.fPosDownStDev is None:
        self.fPosDownStDev = 0.
      if self.fAngleHeading is None:
        self.fAngleHeading = 0.
      if self.fAnglePitch is None:
        self.fAnglePitch = 0.
      if self.fAngleRoll is None:
        self.fAngleRoll = 0.
      if self.fAngleHeadingStDev is None:
        self.fAngleHeadingStDev = 0.
      if self.fAnglePitchStDev is None:
        self.fAnglePitchStDev = 0.
      if self.fAngleRollStDev is None:
        self.fAngleRollStDev = 0.
      if self.fUTMEast is None:
        self.fUTMEast = 0.
      if self.fUTMNorth is None:
        self.fUTMNorth = 0.
      if self.fUTMHeading is None:
        self.fUTMHeading = 0.
      if self.fSpeed2D is None:
        self.fSpeed2D = 0.
      if self.fVelLateral is None:
        self.fVelLateral = 0.
      if self.fVelForward is None:
        self.fVelForward = 0.
      if self.fVelNorth is None:
        self.fVelNorth = 0.
      if self.fVelEast is None:
        self.fVelEast = 0.
      if self.fVelDown is None:
        self.fVelDown = 0.
      if self.fVelNorthStDev is None:
        self.fVelNorthStDev = 0.
      if self.fVelEastStDev is None:
        self.fVelEastStDev = 0.
      if self.fVelDownStDev is None:
        self.fVelDownStDev = 0.
      if self.fAccelX is None:
        self.fAccelX = 0.
      if self.fAccelY is None:
        self.fAccelY = 0.
      if self.fAccelZ is None:
        self.fAccelZ = 0.
      if self.fAngRateZ is None:
        self.fAngRateZ = 0.
      if self.fAngRateY is None:
        self.fAngRateY = 0.
      if self.fAngRateX is None:
        self.fAngRateX = 0.
    else:
      self.header = std_msgs.msg.Header()
      self.iTimeUTC_Microseconds = 0
      self.iTimeGPS_Microseconds = 0
      self.iTimeHour = 0
      self.iTimeMinute = 0
      self.iTimeSecond = 0
      self.fTimeHSecond = 0.
      self.iTimeDay = 0
      self.iTimeMonth = 0
      self.iTimeYear = 0
      self.iSatellitesUsed = 0
      self.nStatus = 0
      self.nStatusExt = 0
      self.fLongitude = 0.
      self.fLatitude = 0.
      self.fAltitude = 0.
      self.fPosNorthStDev = 0.
      self.fPosEastStDev = 0.
      self.fPosDownStDev = 0.
      self.fAngleHeading = 0.
      self.fAnglePitch = 0.
      self.fAngleRoll = 0.
      self.fAngleHeadingStDev = 0.
      self.fAnglePitchStDev = 0.
      self.fAngleRollStDev = 0.
      self.fUTMEast = 0.
      self.fUTMNorth = 0.
      self.fUTMHeading = 0.
      self.fSpeed2D = 0.
      self.fVelLateral = 0.
      self.fVelForward = 0.
      self.fVelNorth = 0.
      self.fVelEast = 0.
      self.fVelDown = 0.
      self.fVelNorthStDev = 0.
      self.fVelEastStDev = 0.
      self.fVelDownStDev = 0.
      self.fAccelX = 0.
      self.fAccelY = 0.
      self.fAccelZ = 0.
      self.fAngRateZ = 0.
      self.fAngRateY = 0.
      self.fAngRateX = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_5Qd3QHhB30d().pack(_x.iTimeUTC_Microseconds, _x.iTimeGPS_Microseconds, _x.iTimeHour, _x.iTimeMinute, _x.iTimeSecond, _x.fTimeHSecond, _x.iTimeDay, _x.iTimeMonth, _x.iTimeYear, _x.iSatellitesUsed, _x.nStatus, _x.nStatusExt, _x.fLongitude, _x.fLatitude, _x.fAltitude, _x.fPosNorthStDev, _x.fPosEastStDev, _x.fPosDownStDev, _x.fAngleHeading, _x.fAnglePitch, _x.fAngleRoll, _x.fAngleHeadingStDev, _x.fAnglePitchStDev, _x.fAngleRollStDev, _x.fUTMEast, _x.fUTMNorth, _x.fUTMHeading, _x.fSpeed2D, _x.fVelLateral, _x.fVelForward, _x.fVelNorth, _x.fVelEast, _x.fVelDown, _x.fVelNorthStDev, _x.fVelEastStDev, _x.fVelDownStDev, _x.fAccelX, _x.fAccelY, _x.fAccelZ, _x.fAngRateZ, _x.fAngRateY, _x.fAngRateX))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 317
      (_x.iTimeUTC_Microseconds, _x.iTimeGPS_Microseconds, _x.iTimeHour, _x.iTimeMinute, _x.iTimeSecond, _x.fTimeHSecond, _x.iTimeDay, _x.iTimeMonth, _x.iTimeYear, _x.iSatellitesUsed, _x.nStatus, _x.nStatusExt, _x.fLongitude, _x.fLatitude, _x.fAltitude, _x.fPosNorthStDev, _x.fPosEastStDev, _x.fPosDownStDev, _x.fAngleHeading, _x.fAnglePitch, _x.fAngleRoll, _x.fAngleHeadingStDev, _x.fAnglePitchStDev, _x.fAngleRollStDev, _x.fUTMEast, _x.fUTMNorth, _x.fUTMHeading, _x.fSpeed2D, _x.fVelLateral, _x.fVelForward, _x.fVelNorth, _x.fVelEast, _x.fVelDown, _x.fVelNorthStDev, _x.fVelEastStDev, _x.fVelDownStDev, _x.fAccelX, _x.fAccelY, _x.fAccelZ, _x.fAngRateZ, _x.fAngRateY, _x.fAngRateX,) = _get_struct_5Qd3QHhB30d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_5Qd3QHhB30d().pack(_x.iTimeUTC_Microseconds, _x.iTimeGPS_Microseconds, _x.iTimeHour, _x.iTimeMinute, _x.iTimeSecond, _x.fTimeHSecond, _x.iTimeDay, _x.iTimeMonth, _x.iTimeYear, _x.iSatellitesUsed, _x.nStatus, _x.nStatusExt, _x.fLongitude, _x.fLatitude, _x.fAltitude, _x.fPosNorthStDev, _x.fPosEastStDev, _x.fPosDownStDev, _x.fAngleHeading, _x.fAnglePitch, _x.fAngleRoll, _x.fAngleHeadingStDev, _x.fAnglePitchStDev, _x.fAngleRollStDev, _x.fUTMEast, _x.fUTMNorth, _x.fUTMHeading, _x.fSpeed2D, _x.fVelLateral, _x.fVelForward, _x.fVelNorth, _x.fVelEast, _x.fVelDown, _x.fVelNorthStDev, _x.fVelEastStDev, _x.fVelDownStDev, _x.fAccelX, _x.fAccelY, _x.fAccelZ, _x.fAngRateZ, _x.fAngRateY, _x.fAngRateX))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 317
      (_x.iTimeUTC_Microseconds, _x.iTimeGPS_Microseconds, _x.iTimeHour, _x.iTimeMinute, _x.iTimeSecond, _x.fTimeHSecond, _x.iTimeDay, _x.iTimeMonth, _x.iTimeYear, _x.iSatellitesUsed, _x.nStatus, _x.nStatusExt, _x.fLongitude, _x.fLatitude, _x.fAltitude, _x.fPosNorthStDev, _x.fPosEastStDev, _x.fPosDownStDev, _x.fAngleHeading, _x.fAnglePitch, _x.fAngleRoll, _x.fAngleHeadingStDev, _x.fAnglePitchStDev, _x.fAngleRollStDev, _x.fUTMEast, _x.fUTMNorth, _x.fUTMHeading, _x.fSpeed2D, _x.fVelLateral, _x.fVelForward, _x.fVelNorth, _x.fVelEast, _x.fVelDown, _x.fVelNorthStDev, _x.fVelEastStDev, _x.fVelDownStDev, _x.fAccelX, _x.fAccelY, _x.fAccelZ, _x.fAngRateZ, _x.fAngRateY, _x.fAngRateX,) = _get_struct_5Qd3QHhB30d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_5Qd3QHhB30d = None
def _get_struct_5Qd3QHhB30d():
    global _struct_5Qd3QHhB30d
    if _struct_5Qd3QHhB30d is None:
        _struct_5Qd3QHhB30d = struct.Struct("<5Qd3QHhB30d")
    return _struct_5Qd3QHhB30d
