# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from definitions/v2x_SPAT_IntersectionState.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import definitions.msg

class v2x_SPAT_IntersectionState(genpy.Message):
  _md5sum = "224b7a034dedbe593efc810a744dc511"
  _type = "definitions/v2x_SPAT_IntersectionState"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """string name 
bool name_present
#IntersectionReferenceID id
    uint16 id_region
    bool id_region_present
    uint16 id_id
uint8 revision
ASN_bitstring status
uint32 moy
bool moy_present
uint32 timeStamp
bool timeStamp_present
#uint8[] enabledLanes #alternative 
v2x_SPAT_LaneID[] enabledLanes
bool enabledLanes_present
v2x_SPAT_MovementState[] states#enumerated
v2x_SPAT_ConnectionManeuverAssist[] maneuverAssistList
bool maneuverAssistList_present
uint8[] priority#octet string
bool priority_present
uint8[] preempt#octet string
bool preempt_present
v2x_SPAT_PrioritizationResponse[] regional #enumerated
bool regional_present
================================================================================
MSG: definitions/ASN_bitstring
uint8[] buf
uint8 bits_unused

================================================================================
MSG: definitions/v2x_SPAT_LaneID
uint8 laneID
================================================================================
MSG: definitions/v2x_SPAT_MovementState
string movementName
bool movementName_present
uint8 signalGroup
v2x_SPAT_MovementEvent[] state_time_speed#enumerated
v2x_SPAT_ConnectionManeuverAssist[] maneuverAssistList
bool maneuverAssistList_present

#unused
#RegionalMovementState_regional
#bool RegionalMovementState_regional_present
================================================================================
MSG: definitions/v2x_SPAT_MovementEvent
uint8 eventState#states
#TimeChangeDetails timing OPTIONAL
    uint16 timing_startTime
    bool timing_startTime_present
    uint16 timing_minEndTime
    uint16 timing_maxEndTime
    bool timing_maxEndTime_present
    uint16 timing_likelyTime
    bool timing_likelyTime_present
    uint8 timing_confidence
    bool timing_confidence_present
    uint16 timing_nextTime
    bool timing_nextTime_present
bool timing_present
v2x_SPAT_AdvisorySpeed[] speeds#enumerated
bool speeds_present
# regional unused
bool regional_present










================================================================================
MSG: definitions/v2x_SPAT_AdvisorySpeed
uint8 type#enumerated
uint16 speed
bool speed_present
uint8 confidence
bool confidence_present
uint16 distance
bool distance_present
uint8 classID
bool classID_present
#uint8 regional #unused
bool regional_present 
================================================================================
MSG: definitions/v2x_SPAT_ConnectionManeuverAssist
uint8 connectionID
uint16 queueLength
bool queueLength_present
uint16 availableStorageLength
bool availableStorageLength_present
bool waitOnStop
bool waitOnStop_present
bool pedBicycleDetect
bool pedBicycleDetect_present

#RegionalConnectionManeuverAssist regional
    v2x_SPAT_VehicleToLanePosition[] regional_vehicleToLanePositions
    #NodeOffsetPoint OPTIONAL
        uint8 regional_rsuDistanceFromAnchor_choice
        #not used choice=0 
        #Node-XY-20b choice=20
        #Node-XY-22b choice=22
        #Node-XY-24b choice=24
        #Node-XY-26b choice=26
        #Node-XY-28b choice=28
        #Node-XY-32b choice=32
        #Node-LLmD-64b choice=64
          
        int32 regional_rsuDistanceFromAnchor_node_x_lat
        int32 regional_rsuDistanceFromAnchor_node_y_lon
        #unused
        #node-Regional
================================================================================
MSG: definitions/v2x_SPAT_VehicleToLanePosition
uint32 stationID
uint8 laneID
================================================================================
MSG: definitions/v2x_SPAT_PrioritizationResponse
uint32 stationID
uint8 priorState#enumerated
uint8 signalGroup"""
  __slots__ = ['name','name_present','id_region','id_region_present','id_id','revision','status','moy','moy_present','timeStamp','timeStamp_present','enabledLanes','enabledLanes_present','states','maneuverAssistList','maneuverAssistList_present','priority','priority_present','preempt','preempt_present','regional','regional_present']
  _slot_types = ['string','bool','uint16','bool','uint16','uint8','definitions/ASN_bitstring','uint32','bool','uint32','bool','definitions/v2x_SPAT_LaneID[]','bool','definitions/v2x_SPAT_MovementState[]','definitions/v2x_SPAT_ConnectionManeuverAssist[]','bool','uint8[]','bool','uint8[]','bool','definitions/v2x_SPAT_PrioritizationResponse[]','bool']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       name,name_present,id_region,id_region_present,id_id,revision,status,moy,moy_present,timeStamp,timeStamp_present,enabledLanes,enabledLanes_present,states,maneuverAssistList,maneuverAssistList_present,priority,priority_present,preempt,preempt_present,regional,regional_present

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(v2x_SPAT_IntersectionState, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.name is None:
        self.name = ''
      if self.name_present is None:
        self.name_present = False
      if self.id_region is None:
        self.id_region = 0
      if self.id_region_present is None:
        self.id_region_present = False
      if self.id_id is None:
        self.id_id = 0
      if self.revision is None:
        self.revision = 0
      if self.status is None:
        self.status = definitions.msg.ASN_bitstring()
      if self.moy is None:
        self.moy = 0
      if self.moy_present is None:
        self.moy_present = False
      if self.timeStamp is None:
        self.timeStamp = 0
      if self.timeStamp_present is None:
        self.timeStamp_present = False
      if self.enabledLanes is None:
        self.enabledLanes = []
      if self.enabledLanes_present is None:
        self.enabledLanes_present = False
      if self.states is None:
        self.states = []
      if self.maneuverAssistList is None:
        self.maneuverAssistList = []
      if self.maneuverAssistList_present is None:
        self.maneuverAssistList_present = False
      if self.priority is None:
        self.priority = b''
      if self.priority_present is None:
        self.priority_present = False
      if self.preempt is None:
        self.preempt = b''
      if self.preempt_present is None:
        self.preempt_present = False
      if self.regional is None:
        self.regional = []
      if self.regional_present is None:
        self.regional_present = False
    else:
      self.name = ''
      self.name_present = False
      self.id_region = 0
      self.id_region_present = False
      self.id_id = 0
      self.revision = 0
      self.status = definitions.msg.ASN_bitstring()
      self.moy = 0
      self.moy_present = False
      self.timeStamp = 0
      self.timeStamp_present = False
      self.enabledLanes = []
      self.enabledLanes_present = False
      self.states = []
      self.maneuverAssistList = []
      self.maneuverAssistList_present = False
      self.priority = b''
      self.priority_present = False
      self.preempt = b''
      self.preempt_present = False
      self.regional = []
      self.regional_present = False

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_BHBHB().pack(_x.name_present, _x.id_region, _x.id_region_present, _x.id_id, _x.revision))
      _x = self.status.buf
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
      else:
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_BIBIB().pack(_x.status.bits_unused, _x.moy, _x.moy_present, _x.timeStamp, _x.timeStamp_present))
      length = len(self.enabledLanes)
      buff.write(_struct_I.pack(length))
      for val1 in self.enabledLanes:
        _x = val1.laneID
        buff.write(_get_struct_B().pack(_x))
      _x = self.enabledLanes_present
      buff.write(_get_struct_B().pack(_x))
      length = len(self.states)
      buff.write(_struct_I.pack(length))
      for val1 in self.states:
        _x = val1.movementName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_2B().pack(_x.movementName_present, _x.signalGroup))
        length = len(val1.state_time_speed)
        buff.write(_struct_I.pack(length))
        for val2 in val1.state_time_speed:
          _x = val2
          buff.write(_get_struct_BHB2HBH3BH2B().pack(_x.eventState, _x.timing_startTime, _x.timing_startTime_present, _x.timing_minEndTime, _x.timing_maxEndTime, _x.timing_maxEndTime_present, _x.timing_likelyTime, _x.timing_likelyTime_present, _x.timing_confidence, _x.timing_confidence_present, _x.timing_nextTime, _x.timing_nextTime_present, _x.timing_present))
          length = len(val2.speeds)
          buff.write(_struct_I.pack(length))
          for val3 in val2.speeds:
            _x = val3
            buff.write(_get_struct_BH3BH4B().pack(_x.type, _x.speed, _x.speed_present, _x.confidence, _x.confidence_present, _x.distance, _x.distance_present, _x.classID, _x.classID_present, _x.regional_present))
          _x = val2
          buff.write(_get_struct_2B().pack(_x.speeds_present, _x.regional_present))
        length = len(val1.maneuverAssistList)
        buff.write(_struct_I.pack(length))
        for val2 in val1.maneuverAssistList:
          _x = val2
          buff.write(_get_struct_BHBH5B().pack(_x.connectionID, _x.queueLength, _x.queueLength_present, _x.availableStorageLength, _x.availableStorageLength_present, _x.waitOnStop, _x.waitOnStop_present, _x.pedBicycleDetect, _x.pedBicycleDetect_present))
          length = len(val2.regional_vehicleToLanePositions)
          buff.write(_struct_I.pack(length))
          for val3 in val2.regional_vehicleToLanePositions:
            _x = val3
            buff.write(_get_struct_IB().pack(_x.stationID, _x.laneID))
          _x = val2
          buff.write(_get_struct_B2i().pack(_x.regional_rsuDistanceFromAnchor_choice, _x.regional_rsuDistanceFromAnchor_node_x_lat, _x.regional_rsuDistanceFromAnchor_node_y_lon))
        _x = val1.maneuverAssistList_present
        buff.write(_get_struct_B().pack(_x))
      length = len(self.maneuverAssistList)
      buff.write(_struct_I.pack(length))
      for val1 in self.maneuverAssistList:
        _x = val1
        buff.write(_get_struct_BHBH5B().pack(_x.connectionID, _x.queueLength, _x.queueLength_present, _x.availableStorageLength, _x.availableStorageLength_present, _x.waitOnStop, _x.waitOnStop_present, _x.pedBicycleDetect, _x.pedBicycleDetect_present))
        length = len(val1.regional_vehicleToLanePositions)
        buff.write(_struct_I.pack(length))
        for val2 in val1.regional_vehicleToLanePositions:
          _x = val2
          buff.write(_get_struct_IB().pack(_x.stationID, _x.laneID))
        _x = val1
        buff.write(_get_struct_B2i().pack(_x.regional_rsuDistanceFromAnchor_choice, _x.regional_rsuDistanceFromAnchor_node_x_lat, _x.regional_rsuDistanceFromAnchor_node_y_lon))
      _x = self.maneuverAssistList_present
      buff.write(_get_struct_B().pack(_x))
      _x = self.priority
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
      else:
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.priority_present
      buff.write(_get_struct_B().pack(_x))
      _x = self.preempt
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
      else:
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.preempt_present
      buff.write(_get_struct_B().pack(_x))
      length = len(self.regional)
      buff.write(_struct_I.pack(length))
      for val1 in self.regional:
        _x = val1
        buff.write(_get_struct_I2B().pack(_x.stationID, _x.priorState, _x.signalGroup))
      _x = self.regional_present
      buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.status is None:
        self.status = definitions.msg.ASN_bitstring()
      if self.enabledLanes is None:
        self.enabledLanes = None
      if self.states is None:
        self.states = None
      if self.maneuverAssistList is None:
        self.maneuverAssistList = None
      if self.regional is None:
        self.regional = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.name = str[start:end]
      _x = self
      start = end
      end += 7
      (_x.name_present, _x.id_region, _x.id_region_present, _x.id_id, _x.revision,) = _get_struct_BHBHB().unpack(str[start:end])
      self.name_present = bool(self.name_present)
      self.id_region_present = bool(self.id_region_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status.buf = str[start:end]
      _x = self
      start = end
      end += 11
      (_x.status.bits_unused, _x.moy, _x.moy_present, _x.timeStamp, _x.timeStamp_present,) = _get_struct_BIBIB().unpack(str[start:end])
      self.moy_present = bool(self.moy_present)
      self.timeStamp_present = bool(self.timeStamp_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.enabledLanes = []
      for i in range(0, length):
        val1 = definitions.msg.v2x_SPAT_LaneID()
        start = end
        end += 1
        (val1.laneID,) = _get_struct_B().unpack(str[start:end])
        self.enabledLanes.append(val1)
      start = end
      end += 1
      (self.enabledLanes_present,) = _get_struct_B().unpack(str[start:end])
      self.enabledLanes_present = bool(self.enabledLanes_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.states = []
      for i in range(0, length):
        val1 = definitions.msg.v2x_SPAT_MovementState()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.movementName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.movementName = str[start:end]
        _x = val1
        start = end
        end += 2
        (_x.movementName_present, _x.signalGroup,) = _get_struct_2B().unpack(str[start:end])
        val1.movementName_present = bool(val1.movementName_present)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.state_time_speed = []
        for i in range(0, length):
          val2 = definitions.msg.v2x_SPAT_MovementEvent()
          _x = val2
          start = end
          end += 18
          (_x.eventState, _x.timing_startTime, _x.timing_startTime_present, _x.timing_minEndTime, _x.timing_maxEndTime, _x.timing_maxEndTime_present, _x.timing_likelyTime, _x.timing_likelyTime_present, _x.timing_confidence, _x.timing_confidence_present, _x.timing_nextTime, _x.timing_nextTime_present, _x.timing_present,) = _get_struct_BHB2HBH3BH2B().unpack(str[start:end])
          val2.timing_startTime_present = bool(val2.timing_startTime_present)
          val2.timing_maxEndTime_present = bool(val2.timing_maxEndTime_present)
          val2.timing_likelyTime_present = bool(val2.timing_likelyTime_present)
          val2.timing_confidence_present = bool(val2.timing_confidence_present)
          val2.timing_nextTime_present = bool(val2.timing_nextTime_present)
          val2.timing_present = bool(val2.timing_present)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.speeds = []
          for i in range(0, length):
            val3 = definitions.msg.v2x_SPAT_AdvisorySpeed()
            _x = val3
            start = end
            end += 12
            (_x.type, _x.speed, _x.speed_present, _x.confidence, _x.confidence_present, _x.distance, _x.distance_present, _x.classID, _x.classID_present, _x.regional_present,) = _get_struct_BH3BH4B().unpack(str[start:end])
            val3.speed_present = bool(val3.speed_present)
            val3.confidence_present = bool(val3.confidence_present)
            val3.distance_present = bool(val3.distance_present)
            val3.classID_present = bool(val3.classID_present)
            val3.regional_present = bool(val3.regional_present)
            val2.speeds.append(val3)
          _x = val2
          start = end
          end += 2
          (_x.speeds_present, _x.regional_present,) = _get_struct_2B().unpack(str[start:end])
          val2.speeds_present = bool(val2.speeds_present)
          val2.regional_present = bool(val2.regional_present)
          val1.state_time_speed.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.maneuverAssistList = []
        for i in range(0, length):
          val2 = definitions.msg.v2x_SPAT_ConnectionManeuverAssist()
          _x = val2
          start = end
          end += 11
          (_x.connectionID, _x.queueLength, _x.queueLength_present, _x.availableStorageLength, _x.availableStorageLength_present, _x.waitOnStop, _x.waitOnStop_present, _x.pedBicycleDetect, _x.pedBicycleDetect_present,) = _get_struct_BHBH5B().unpack(str[start:end])
          val2.queueLength_present = bool(val2.queueLength_present)
          val2.availableStorageLength_present = bool(val2.availableStorageLength_present)
          val2.waitOnStop = bool(val2.waitOnStop)
          val2.waitOnStop_present = bool(val2.waitOnStop_present)
          val2.pedBicycleDetect = bool(val2.pedBicycleDetect)
          val2.pedBicycleDetect_present = bool(val2.pedBicycleDetect_present)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.regional_vehicleToLanePositions = []
          for i in range(0, length):
            val3 = definitions.msg.v2x_SPAT_VehicleToLanePosition()
            _x = val3
            start = end
            end += 5
            (_x.stationID, _x.laneID,) = _get_struct_IB().unpack(str[start:end])
            val2.regional_vehicleToLanePositions.append(val3)
          _x = val2
          start = end
          end += 9
          (_x.regional_rsuDistanceFromAnchor_choice, _x.regional_rsuDistanceFromAnchor_node_x_lat, _x.regional_rsuDistanceFromAnchor_node_y_lon,) = _get_struct_B2i().unpack(str[start:end])
          val1.maneuverAssistList.append(val2)
        start = end
        end += 1
        (val1.maneuverAssistList_present,) = _get_struct_B().unpack(str[start:end])
        val1.maneuverAssistList_present = bool(val1.maneuverAssistList_present)
        self.states.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.maneuverAssistList = []
      for i in range(0, length):
        val1 = definitions.msg.v2x_SPAT_ConnectionManeuverAssist()
        _x = val1
        start = end
        end += 11
        (_x.connectionID, _x.queueLength, _x.queueLength_present, _x.availableStorageLength, _x.availableStorageLength_present, _x.waitOnStop, _x.waitOnStop_present, _x.pedBicycleDetect, _x.pedBicycleDetect_present,) = _get_struct_BHBH5B().unpack(str[start:end])
        val1.queueLength_present = bool(val1.queueLength_present)
        val1.availableStorageLength_present = bool(val1.availableStorageLength_present)
        val1.waitOnStop = bool(val1.waitOnStop)
        val1.waitOnStop_present = bool(val1.waitOnStop_present)
        val1.pedBicycleDetect = bool(val1.pedBicycleDetect)
        val1.pedBicycleDetect_present = bool(val1.pedBicycleDetect_present)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.regional_vehicleToLanePositions = []
        for i in range(0, length):
          val2 = definitions.msg.v2x_SPAT_VehicleToLanePosition()
          _x = val2
          start = end
          end += 5
          (_x.stationID, _x.laneID,) = _get_struct_IB().unpack(str[start:end])
          val1.regional_vehicleToLanePositions.append(val2)
        _x = val1
        start = end
        end += 9
        (_x.regional_rsuDistanceFromAnchor_choice, _x.regional_rsuDistanceFromAnchor_node_x_lat, _x.regional_rsuDistanceFromAnchor_node_y_lon,) = _get_struct_B2i().unpack(str[start:end])
        self.maneuverAssistList.append(val1)
      start = end
      end += 1
      (self.maneuverAssistList_present,) = _get_struct_B().unpack(str[start:end])
      self.maneuverAssistList_present = bool(self.maneuverAssistList_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.priority = str[start:end]
      start = end
      end += 1
      (self.priority_present,) = _get_struct_B().unpack(str[start:end])
      self.priority_present = bool(self.priority_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.preempt = str[start:end]
      start = end
      end += 1
      (self.preempt_present,) = _get_struct_B().unpack(str[start:end])
      self.preempt_present = bool(self.preempt_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.regional = []
      for i in range(0, length):
        val1 = definitions.msg.v2x_SPAT_PrioritizationResponse()
        _x = val1
        start = end
        end += 6
        (_x.stationID, _x.priorState, _x.signalGroup,) = _get_struct_I2B().unpack(str[start:end])
        self.regional.append(val1)
      start = end
      end += 1
      (self.regional_present,) = _get_struct_B().unpack(str[start:end])
      self.regional_present = bool(self.regional_present)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_BHBHB().pack(_x.name_present, _x.id_region, _x.id_region_present, _x.id_id, _x.revision))
      _x = self.status.buf
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
      else:
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_BIBIB().pack(_x.status.bits_unused, _x.moy, _x.moy_present, _x.timeStamp, _x.timeStamp_present))
      length = len(self.enabledLanes)
      buff.write(_struct_I.pack(length))
      for val1 in self.enabledLanes:
        _x = val1.laneID
        buff.write(_get_struct_B().pack(_x))
      _x = self.enabledLanes_present
      buff.write(_get_struct_B().pack(_x))
      length = len(self.states)
      buff.write(_struct_I.pack(length))
      for val1 in self.states:
        _x = val1.movementName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_2B().pack(_x.movementName_present, _x.signalGroup))
        length = len(val1.state_time_speed)
        buff.write(_struct_I.pack(length))
        for val2 in val1.state_time_speed:
          _x = val2
          buff.write(_get_struct_BHB2HBH3BH2B().pack(_x.eventState, _x.timing_startTime, _x.timing_startTime_present, _x.timing_minEndTime, _x.timing_maxEndTime, _x.timing_maxEndTime_present, _x.timing_likelyTime, _x.timing_likelyTime_present, _x.timing_confidence, _x.timing_confidence_present, _x.timing_nextTime, _x.timing_nextTime_present, _x.timing_present))
          length = len(val2.speeds)
          buff.write(_struct_I.pack(length))
          for val3 in val2.speeds:
            _x = val3
            buff.write(_get_struct_BH3BH4B().pack(_x.type, _x.speed, _x.speed_present, _x.confidence, _x.confidence_present, _x.distance, _x.distance_present, _x.classID, _x.classID_present, _x.regional_present))
          _x = val2
          buff.write(_get_struct_2B().pack(_x.speeds_present, _x.regional_present))
        length = len(val1.maneuverAssistList)
        buff.write(_struct_I.pack(length))
        for val2 in val1.maneuverAssistList:
          _x = val2
          buff.write(_get_struct_BHBH5B().pack(_x.connectionID, _x.queueLength, _x.queueLength_present, _x.availableStorageLength, _x.availableStorageLength_present, _x.waitOnStop, _x.waitOnStop_present, _x.pedBicycleDetect, _x.pedBicycleDetect_present))
          length = len(val2.regional_vehicleToLanePositions)
          buff.write(_struct_I.pack(length))
          for val3 in val2.regional_vehicleToLanePositions:
            _x = val3
            buff.write(_get_struct_IB().pack(_x.stationID, _x.laneID))
          _x = val2
          buff.write(_get_struct_B2i().pack(_x.regional_rsuDistanceFromAnchor_choice, _x.regional_rsuDistanceFromAnchor_node_x_lat, _x.regional_rsuDistanceFromAnchor_node_y_lon))
        _x = val1.maneuverAssistList_present
        buff.write(_get_struct_B().pack(_x))
      length = len(self.maneuverAssistList)
      buff.write(_struct_I.pack(length))
      for val1 in self.maneuverAssistList:
        _x = val1
        buff.write(_get_struct_BHBH5B().pack(_x.connectionID, _x.queueLength, _x.queueLength_present, _x.availableStorageLength, _x.availableStorageLength_present, _x.waitOnStop, _x.waitOnStop_present, _x.pedBicycleDetect, _x.pedBicycleDetect_present))
        length = len(val1.regional_vehicleToLanePositions)
        buff.write(_struct_I.pack(length))
        for val2 in val1.regional_vehicleToLanePositions:
          _x = val2
          buff.write(_get_struct_IB().pack(_x.stationID, _x.laneID))
        _x = val1
        buff.write(_get_struct_B2i().pack(_x.regional_rsuDistanceFromAnchor_choice, _x.regional_rsuDistanceFromAnchor_node_x_lat, _x.regional_rsuDistanceFromAnchor_node_y_lon))
      _x = self.maneuverAssistList_present
      buff.write(_get_struct_B().pack(_x))
      _x = self.priority
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
      else:
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.priority_present
      buff.write(_get_struct_B().pack(_x))
      _x = self.preempt
      length = len(_x)
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
      else:
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.preempt_present
      buff.write(_get_struct_B().pack(_x))
      length = len(self.regional)
      buff.write(_struct_I.pack(length))
      for val1 in self.regional:
        _x = val1
        buff.write(_get_struct_I2B().pack(_x.stationID, _x.priorState, _x.signalGroup))
      _x = self.regional_present
      buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.status is None:
        self.status = definitions.msg.ASN_bitstring()
      if self.enabledLanes is None:
        self.enabledLanes = None
      if self.states is None:
        self.states = None
      if self.maneuverAssistList is None:
        self.maneuverAssistList = None
      if self.regional is None:
        self.regional = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.name = str[start:end]
      _x = self
      start = end
      end += 7
      (_x.name_present, _x.id_region, _x.id_region_present, _x.id_id, _x.revision,) = _get_struct_BHBHB().unpack(str[start:end])
      self.name_present = bool(self.name_present)
      self.id_region_present = bool(self.id_region_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.status.buf = str[start:end]
      _x = self
      start = end
      end += 11
      (_x.status.bits_unused, _x.moy, _x.moy_present, _x.timeStamp, _x.timeStamp_present,) = _get_struct_BIBIB().unpack(str[start:end])
      self.moy_present = bool(self.moy_present)
      self.timeStamp_present = bool(self.timeStamp_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.enabledLanes = []
      for i in range(0, length):
        val1 = definitions.msg.v2x_SPAT_LaneID()
        start = end
        end += 1
        (val1.laneID,) = _get_struct_B().unpack(str[start:end])
        self.enabledLanes.append(val1)
      start = end
      end += 1
      (self.enabledLanes_present,) = _get_struct_B().unpack(str[start:end])
      self.enabledLanes_present = bool(self.enabledLanes_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.states = []
      for i in range(0, length):
        val1 = definitions.msg.v2x_SPAT_MovementState()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.movementName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.movementName = str[start:end]
        _x = val1
        start = end
        end += 2
        (_x.movementName_present, _x.signalGroup,) = _get_struct_2B().unpack(str[start:end])
        val1.movementName_present = bool(val1.movementName_present)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.state_time_speed = []
        for i in range(0, length):
          val2 = definitions.msg.v2x_SPAT_MovementEvent()
          _x = val2
          start = end
          end += 18
          (_x.eventState, _x.timing_startTime, _x.timing_startTime_present, _x.timing_minEndTime, _x.timing_maxEndTime, _x.timing_maxEndTime_present, _x.timing_likelyTime, _x.timing_likelyTime_present, _x.timing_confidence, _x.timing_confidence_present, _x.timing_nextTime, _x.timing_nextTime_present, _x.timing_present,) = _get_struct_BHB2HBH3BH2B().unpack(str[start:end])
          val2.timing_startTime_present = bool(val2.timing_startTime_present)
          val2.timing_maxEndTime_present = bool(val2.timing_maxEndTime_present)
          val2.timing_likelyTime_present = bool(val2.timing_likelyTime_present)
          val2.timing_confidence_present = bool(val2.timing_confidence_present)
          val2.timing_nextTime_present = bool(val2.timing_nextTime_present)
          val2.timing_present = bool(val2.timing_present)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.speeds = []
          for i in range(0, length):
            val3 = definitions.msg.v2x_SPAT_AdvisorySpeed()
            _x = val3
            start = end
            end += 12
            (_x.type, _x.speed, _x.speed_present, _x.confidence, _x.confidence_present, _x.distance, _x.distance_present, _x.classID, _x.classID_present, _x.regional_present,) = _get_struct_BH3BH4B().unpack(str[start:end])
            val3.speed_present = bool(val3.speed_present)
            val3.confidence_present = bool(val3.confidence_present)
            val3.distance_present = bool(val3.distance_present)
            val3.classID_present = bool(val3.classID_present)
            val3.regional_present = bool(val3.regional_present)
            val2.speeds.append(val3)
          _x = val2
          start = end
          end += 2
          (_x.speeds_present, _x.regional_present,) = _get_struct_2B().unpack(str[start:end])
          val2.speeds_present = bool(val2.speeds_present)
          val2.regional_present = bool(val2.regional_present)
          val1.state_time_speed.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.maneuverAssistList = []
        for i in range(0, length):
          val2 = definitions.msg.v2x_SPAT_ConnectionManeuverAssist()
          _x = val2
          start = end
          end += 11
          (_x.connectionID, _x.queueLength, _x.queueLength_present, _x.availableStorageLength, _x.availableStorageLength_present, _x.waitOnStop, _x.waitOnStop_present, _x.pedBicycleDetect, _x.pedBicycleDetect_present,) = _get_struct_BHBH5B().unpack(str[start:end])
          val2.queueLength_present = bool(val2.queueLength_present)
          val2.availableStorageLength_present = bool(val2.availableStorageLength_present)
          val2.waitOnStop = bool(val2.waitOnStop)
          val2.waitOnStop_present = bool(val2.waitOnStop_present)
          val2.pedBicycleDetect = bool(val2.pedBicycleDetect)
          val2.pedBicycleDetect_present = bool(val2.pedBicycleDetect_present)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.regional_vehicleToLanePositions = []
          for i in range(0, length):
            val3 = definitions.msg.v2x_SPAT_VehicleToLanePosition()
            _x = val3
            start = end
            end += 5
            (_x.stationID, _x.laneID,) = _get_struct_IB().unpack(str[start:end])
            val2.regional_vehicleToLanePositions.append(val3)
          _x = val2
          start = end
          end += 9
          (_x.regional_rsuDistanceFromAnchor_choice, _x.regional_rsuDistanceFromAnchor_node_x_lat, _x.regional_rsuDistanceFromAnchor_node_y_lon,) = _get_struct_B2i().unpack(str[start:end])
          val1.maneuverAssistList.append(val2)
        start = end
        end += 1
        (val1.maneuverAssistList_present,) = _get_struct_B().unpack(str[start:end])
        val1.maneuverAssistList_present = bool(val1.maneuverAssistList_present)
        self.states.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.maneuverAssistList = []
      for i in range(0, length):
        val1 = definitions.msg.v2x_SPAT_ConnectionManeuverAssist()
        _x = val1
        start = end
        end += 11
        (_x.connectionID, _x.queueLength, _x.queueLength_present, _x.availableStorageLength, _x.availableStorageLength_present, _x.waitOnStop, _x.waitOnStop_present, _x.pedBicycleDetect, _x.pedBicycleDetect_present,) = _get_struct_BHBH5B().unpack(str[start:end])
        val1.queueLength_present = bool(val1.queueLength_present)
        val1.availableStorageLength_present = bool(val1.availableStorageLength_present)
        val1.waitOnStop = bool(val1.waitOnStop)
        val1.waitOnStop_present = bool(val1.waitOnStop_present)
        val1.pedBicycleDetect = bool(val1.pedBicycleDetect)
        val1.pedBicycleDetect_present = bool(val1.pedBicycleDetect_present)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.regional_vehicleToLanePositions = []
        for i in range(0, length):
          val2 = definitions.msg.v2x_SPAT_VehicleToLanePosition()
          _x = val2
          start = end
          end += 5
          (_x.stationID, _x.laneID,) = _get_struct_IB().unpack(str[start:end])
          val1.regional_vehicleToLanePositions.append(val2)
        _x = val1
        start = end
        end += 9
        (_x.regional_rsuDistanceFromAnchor_choice, _x.regional_rsuDistanceFromAnchor_node_x_lat, _x.regional_rsuDistanceFromAnchor_node_y_lon,) = _get_struct_B2i().unpack(str[start:end])
        self.maneuverAssistList.append(val1)
      start = end
      end += 1
      (self.maneuverAssistList_present,) = _get_struct_B().unpack(str[start:end])
      self.maneuverAssistList_present = bool(self.maneuverAssistList_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.priority = str[start:end]
      start = end
      end += 1
      (self.priority_present,) = _get_struct_B().unpack(str[start:end])
      self.priority_present = bool(self.priority_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      self.preempt = str[start:end]
      start = end
      end += 1
      (self.preempt_present,) = _get_struct_B().unpack(str[start:end])
      self.preempt_present = bool(self.preempt_present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.regional = []
      for i in range(0, length):
        val1 = definitions.msg.v2x_SPAT_PrioritizationResponse()
        _x = val1
        start = end
        end += 6
        (_x.stationID, _x.priorState, _x.signalGroup,) = _get_struct_I2B().unpack(str[start:end])
        self.regional.append(val1)
      start = end
      end += 1
      (self.regional_present,) = _get_struct_B().unpack(str[start:end])
      self.regional_present = bool(self.regional_present)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2B = None
def _get_struct_2B():
    global _struct_2B
    if _struct_2B is None:
        _struct_2B = struct.Struct("<2B")
    return _struct_2B
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_B2i = None
def _get_struct_B2i():
    global _struct_B2i
    if _struct_B2i is None:
        _struct_B2i = struct.Struct("<B2i")
    return _struct_B2i
_struct_BH3BH4B = None
def _get_struct_BH3BH4B():
    global _struct_BH3BH4B
    if _struct_BH3BH4B is None:
        _struct_BH3BH4B = struct.Struct("<BH3BH4B")
    return _struct_BH3BH4B
_struct_BHB2HBH3BH2B = None
def _get_struct_BHB2HBH3BH2B():
    global _struct_BHB2HBH3BH2B
    if _struct_BHB2HBH3BH2B is None:
        _struct_BHB2HBH3BH2B = struct.Struct("<BHB2HBH3BH2B")
    return _struct_BHB2HBH3BH2B
_struct_BHBH5B = None
def _get_struct_BHBH5B():
    global _struct_BHBH5B
    if _struct_BHBH5B is None:
        _struct_BHBH5B = struct.Struct("<BHBH5B")
    return _struct_BHBH5B
_struct_BHBHB = None
def _get_struct_BHBHB():
    global _struct_BHBHB
    if _struct_BHBHB is None:
        _struct_BHBHB = struct.Struct("<BHBHB")
    return _struct_BHBHB
_struct_BIBIB = None
def _get_struct_BIBIB():
    global _struct_BIBIB
    if _struct_BIBIB is None:
        _struct_BIBIB = struct.Struct("<BIBIB")
    return _struct_BIBIB
_struct_I2B = None
def _get_struct_I2B():
    global _struct_I2B
    if _struct_I2B is None:
        _struct_I2B = struct.Struct("<I2B")
    return _struct_I2B
_struct_IB = None
def _get_struct_IB():
    global _struct_IB
    if _struct_IB is None:
        _struct_IB = struct.Struct("<IB")
    return _struct_IB
